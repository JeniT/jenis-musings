<p><a href="http://www.ltg.ed.ac.uk/%7Eht/" title="Henry S. Thompson&#39;s Home Page">Henry Thompson</a> had a lot to say after <a href="http://www.jenitennison.com/blog/files/XTech2007CreoleSlides.zip" title="XTech 2007 Creole presentation">my Creole presentation</a> (open takahashi.xul?data=creole.data; requires Firefox) about the benefits of stand-off markup for linguistic information. From his overview, it seems that the <a href="http://www.ltg.ed.ac.uk/NITE" title="NITE XML Toolkit">NITE XML Toolkit</a> that he&#39;s been involved with represents overlapping linguistic data by holding atoms (here meaning the &quot;lowest common denominator&quot; shared pieces of data) and having multiple trees marking up these atoms. The trees are independently validated (since they are pure XML), with cross-hierarchy validation done through the query language. This is pretty similar to the <a href="http://www.idealliance.org/papers/extreme/Proceedings/html/2006/Schonefeld01/EML2006Schonefeld01.html" title="Towards Validation of Concurrent Markup">XCONCUR</a> approach, which augments a CONCUR-like multi-grammar validation with a Schematron-like constraint language.</p>

<!--break-->

<p>Now, I have nothing against using constraint languages (like Schematron) to validate documents, but grammars (like RELAX NG) have big advantages. Most importantly, they are easier to write (if they&#39;re designed properly), and tools can analyse them to do useful things, such as tell you what element or attribute is expected next. If it&#39;s possible to write cross-grammar constraints in a grammar (like Creole) then why would you use a constraint language to do it?</p>

<p>I think the big difference between Henry&#39;s domain and the one that I think will move overlap into the mainstream is between global and local concurrence. With global concurrence, entirely separate hierarchies are applied to the same data, so the natural validation mechanism is to use entirely separate grammars (with perhaps a few small rules to do cross-grammar validation where that proves necessary). With local concurrence, the vast majority of the document follows a single hierarchy with concurrence happening at a low level.</p>

<p>Actually, the best example for this doesn&#39;t even involve overlap. Consider HTML paragraphs, which contain various inline elements such as <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code> and <code>&lt;a&gt;</code>. It doesn&#39;t make sense for these elements to contain themselves (strong text is neither made stronger nor negated by appearing in two <code>&lt;strong&gt;</code> elements, and it&#39;s not allowed for links to contain other links). So the natural model in Creole is</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">p      = element p { mixed { strong* &amp; em* &amp; a* } }
strong = range strong { text }
em     = range em { text }
a      = range a { attribute href { text }, ..., text }
</code></pre></div>
<p>This model allows <code>&lt;a&gt;</code> elements to appear within <code>&lt;em&gt;</code> elements, or vice versa, not because of the content model of <code>&lt;em&gt;</code> but because the two ranges are interleaved (and one arrangement of interleaved ranges is containment). It doesn&#39;t allow any of these elements to appear inside themselves. It would be a real maintenance headache to have separate grammars for each of these inline elements, when most of each of the grammars (all the hierarchy down to the paragraph level) would be the same.</p>

<p>Actually, looking at NITE, it seems like it employs a data model that&#39;s quite like <a href="http://www.lmnlwiki.org/index.php/LMNL_data_model" title="LMNL data model">LMNL&#39;s</a>, in that it has the concept of layers over atoms or ranges/elements. (Interestingly it looks like they get around the problem of identifying which ranges belong to which layers purely by using their name.) Another difference here might be that while I&#39;m talking about supporting overlap in fairly heavily structured documents (like office documents), they&#39;re really using fairly flat annotations, where there isn&#39;t much of a grammar anyway. But I might have that wrong: need to do more reading. The other thing to investigate is whether they have any support for self-overlap (<code>&lt;phrase&gt;</code> elements overlapping other <code>&lt;phrase&gt;</code> elements): I kinda gather that they don&#39;t.</p>

<p>Anyway, Henry also made the points that (a) that he doesn&#39;t want a new syntax for overlap and (b) stand-off markup works very well thank you. To address the latter point first, I think stand-off markup works very well if you have the tools to support it. It&#39;s fine if you have an integrated toolkit which can pull together and display the stand-off markup as embedded markup, and let you create ranges by highlighting text with a mouse. But the great power of HTML and other web technologies is that you don&#39;t need to use a specialised toolkit to write it: you can just use a text editor and it&#39;s all right there in front of you with no (or minimal) cross-referencing required. Frankly, I&#39;m not interested in &quot;core&quot; technologies that require me to install a particular piece of software in order to make use of them (cf <a href="http://research.microsoft.com/%7Eemeijer/" title="Erik Meijer&#39;s Home Page">Erik Meijer</a>&#39;s talk on <a href="http://msdn.microsoft.com/data/ref/linq/" title="LINQ">LINQ</a>, which I&#39;ll have to discuss another time). I expect to be able to write a document containing overlap as easily as I can write a normal XML document.</p>

<p>On Henry&#39;s point about yet another syntax for overlap, I am more and more coming to the conclusion that overlap will hit the mainstream if we have a simple way of encoding overlap in normal XML documents, namely something along the lines of <a href="http://www.lmnlwiki.org/index.php/Talk:ECLIX#LIX" title="LMNL-in-XML">LIX</a>. Interestingly, <a href="http://www.translate.com/" title="Yves Savourel&#39;s Website">Yves Savourel</a>&#39;s talk on Applying the <a href="http://www.w3.org/TR/2007/REC-its-20070403/" title="Internationalization Tag Set (ITS) Version 1.0">Internationalization Tag Set</a> was quite inspirational in this regard, since the working group seem to have put together a standard that both provides a set of standard elements and attributes to guide localisation, along with a method of mapping elements and attributes in existing markup languages onto those ITS elements and attributes. I wonder whether a similar approach could be used with LIX... but I&#39;ll have to leave those thoughts for another time.</p>
